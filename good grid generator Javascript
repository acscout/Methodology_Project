var canvas = document.querySelector('canvas');
// obviously we can change the canvas size as we like
canvas.width = window.innerWidth / 2;
canvas.height = canvas.width;

var mouse = {
  x: undefined, // x and y coordinates for mouse
  y: undefined
};

var n_blocks = 3; // n_blocks refers to the number of blocks per side
var total_blocks = n_blocks * n_blocks;
var n_players = 7; // indicates the number of players
var turns_per_player = Math.floor(total_blocks / n_players); // rounds down number of turns
var total_player_turns = turns_per_player * n_players;
var extra_blocks = total_blocks - total_player_turns; // number of blocks that will be unused
var grid_arr = []; // contains the color values of each square ('0' means uncolored)
var unused_block_color = "black";
var user_arr = ["#f9d5e5", "#eeac99", "#e06377", "#c83349", "#5b9aa0", "#b8a9c9", "#622569"]; // color for each player
var iuser = 0; // current user
var iturn = 0; // current turn of user
var unclicked_color = "white"; // color for an unclicked grid


// setup grid_arr as 0's (no clicked cells)
makeArray(n_blocks, n_blocks, grid_arr);
// draw 10*10 grid
drawGrid(n_blocks);

// click event
canvas.addEventListener('click', clickGrid, false);


// clicks on appropiate block within the grid
function clickGrid(event) {
  mouse.x = event.x;
  mouse.y = event.y;
  var c = canvas.getContext('2d');
  var block_length = canvas.width / n_blocks;
  var block_x = Math.floor(mouse.x / block_length);
  var block_y = Math.floor(mouse.y / block_length);

  // if grid block is unclicked, click it
  if (grid_arr[block_x][block_y] == "not selected") {
    // check if player is out of turns
    if (turns_per_player == iturn) {
      // check if the extra blocks need to be filled
      iuser++;
      iturn = 0;
    }
    iturn++;

    // check if all the moves have been selected
    // if so click on box
    if (iuser < n_players) {
      grid_arr[block_x][block_y] = iuser;
      c.fillStyle = user_arr[iuser];
      c.fillRect(block_x * block_length, block_y * block_length, block_length, block_length);

    } else {
      // else the extra boxes are unused
      for (var i = 0; i < n_blocks; i++) {
        for (var j = 0; j < n_blocks; j++) {
          if (grid_arr[i][j] == "not selected") {
            grid_arr[i][j] = "null";
            c.fillStyle = unused_block_color; //extra_color;
            c.fillRect(i * block_length, j * block_length, block_length, block_length);
            //        c.fillRect(0, 0, block_length, block_length);
          }
        }
      }

    }
  }



  // grid is clicked
  else {
    // protect previously selected grids by other players
    /*       grid_arr[block_x][block_y] = "not selected";
          c.fillStyle = unclicked_color;
          c.fillRect(block_x * block_length, block_y * block_length, block_length, block_length); */
  }

}

// draws n_blocks * n_blocks grid
function drawGrid(n_blocks) {
  var c = canvas.getContext('2d');
  var block_length = canvas.width / n_blocks;

  for (xBlock = 0; xBlock < n_blocks; xBlock++) {
    for (yBlock = 0; yBlock < n_blocks; yBlock++) {
      c.rect(xBlock * block_length, yBlock * block_length, block_length, block_length);
      c.stroke();
      //c.fillStyle = "rgba(192, 225, 235, 1)";
      c.fillStyle = unclicked_color;
      c.fillRect(xBlock * block_length, yBlock * block_length, block_length, block_length);
    }
  }
}


// fills array with 0's
function makeArray(row, col, arr) {
  for (var i = 0; i < row; i++) {
    arr[i] = [];
    for (var j = 0; j < col; j++) {
      arr[i][j] = "not selected";
    }
  }
}
